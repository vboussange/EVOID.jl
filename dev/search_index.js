var documenterSearchIndex = {"docs":
[{"location":"notes/notes.html#Taken-from-gillepsie-algorithm-documentation","page":"Taken from gillepsie algorithm documentation","title":"Taken from gillepsie algorithm documentation","text":"","category":"section"},{"location":"notes/notes.html","page":"Taken from gillepsie algorithm documentation","title":"Taken from gillepsie algorithm documentation","text":"tip: Inversion method\nLet B(t) = sum_i b_i(t) and  D(t) = sum_i d_i(t). Let T_b T_d the time for a birth or death event to occur. Then we have P(T_b  T_d) = fracB(t)B(t) + D(t)  (competing exponentials).Let U be an mathcalU_(01)-distributed random variable and F colon R to 01 be a distribution function. Then we haveP(I_F(U) leq x ) = P(U leq F(x)) = F(x)Thanks to the ***inversion method*** we get the incremental time step dt, exponentially distributed with parameter lambda = R(t), as    dt(omega) = -fraclog(U(omega))R(t) iff X(omega) = exp(-U(t)dt(omega))Time stepsAn event is exponentiallly distributed in time, with parameter lambda = U(t). This makes events memoryless, meaning that the probability of having a birth or death event is always the same, no matter when (P(X  s_t  X  t) = P(X  s).","category":"page"},{"location":"mathematics/pde.html#PDE-Equivalence","page":"PDE Equivalence","title":"PDE Equivalence","text":"","category":"section"},{"location":"mathematics/pde.html#Equivalence-with-PDE-models","page":"PDE Equivalence","title":"Equivalence with PDE models","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"HDR Champagnat Theorem 2.5 Section 2.2","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Recall that the IBM is a Markov process in mathcalM^1 which state at time t is the measure","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"    nu_t = sum_i=1^N_t delta_x_i","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Hence an individual with trait x in population nu_t gives birth to a new individual at rate b(x) and dies at rate","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"    d(x) + int c(xy)(nu_t(dy) - delta_x(dy)) = d(x) - c(xx) + sum_i=1^N_t c(cx_i)","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"The Dirac mass in the integral stands for the fact that an individual is not in competition with itself. Hence when N_t = 1 the competition term cancels. When there is birth,  with probability p(x) the offspring has trait y = x + H where H is a random variablee with law m(xh)dh.","category":"page"},{"location":"mathematics/pde.html#Assumptions","page":"PDE Equivalence","title":"Assumptions","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Assume that","category":"page"},{"location":"mathematics/pde.html#Assumption-1-:-bounds-and-parameters-regularity.","page":"PDE Equivalence","title":"Assumption 1 : bounds and parameters regularity.","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Functions bcdp are continuous and bounded, with positive are nul values\nexists barm forall x in D h in R^d m(xh) leq barm(h)","category":"page"},{"location":"mathematics/pde.html#Assumption-2","page":"PDE Equivalence","title":"Assumption 2","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"nu_t^K = frac1Knu_t where nu_t is constructed such that cequiv frac1Kc","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":" ","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Then we get the large population limit without mutation scaling","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"    partial_t u(tx) = u(tx) left((1-p(x))b(x) -d(x) int_D c(xy) u(ty) dyright) + int_D b(x)  p(y)  u(ty)  m(yx-y)dy","category":"page"},{"location":"mathematics/pde.html#Mutations","page":"PDE Equivalence","title":"Mutations","text":"","category":"section"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"Assuming a small mutational variance max sigma^2_i  1 and a mutation rate U, the mutational effects can be approximated by an elliptic operator sum_i=1^n (mu_i^2x)partial_ii with mu_i = sigma_isqrtU","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":":warning: check that with Burger","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"In other words (from Champagnat, Ferriere and Meleard 2006), we have","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"partial_t u(tx) =  u(tx)big(b(tx) - d(xu(tx)) big) + frac12 Delta (sigma^2 r mu u)(tx)","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"where ","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"d(xu(tx)) = (u ast c)(x)","category":"page"},{"location":"mathematics/pde.html","page":"PDE Equivalence","title":"PDE Equivalence","text":"and c is the competition function. For us, x in","category":"page"},{"location":"examples/dynamic_graphs.html#Dynamic-graph","page":"Dynamic graph","title":"Dynamic graph","text":"","category":"section"},{"location":"examples/dynamic_graphs.html","page":"Dynamic graph","title":"Dynamic graph","text":"in EvoId.jl, individuals can evolve over graphs which connectivity can change over time.","category":"page"},{"location":"examples/dynamic_graphs.html","page":"Dynamic graph","title":"Dynamic graph","text":"To define such a dynamic graph, one needs to use the constructor DynGraphSpace.","category":"page"},{"location":"examples/dynamic_graphs.html","page":"Dynamic graph","title":"Dynamic graph","text":"DynGraphSpace","category":"page"},{"location":"examples/dynamic_graphs.html#EvoId.DynGraphSpace","page":"Dynamic graph","title":"EvoId.DynGraphSpace","text":"DynGraphSpace(g, f)\n\nA dynamic graph space.\n\nArguments\n\ng the underlying graph\nf a function that takes as argument time,\n\nand returns the index of the graph to pick at time t from array g\n\nExample\n\nDynGraphSpace(g,f)\n\n\n\n\n\n","category":"type"},{"location":"examples/dynamic_graphs.html","page":"Dynamic graph","title":"Dynamic graph","text":"Here is an example","category":"page"},{"location":"examples/dynamic_graphs.html","page":"Dynamic graph","title":"Dynamic graph","text":"using UnPack,EvoId,LightGraphs\nnodes = 10\ng1 = LightGraphs.grid(Int8[9,1])\ng2 = SimpleGraph(Int8(9))\ng = [g1,g2] # array of graphs\n# This is the function to implement DynGraphSpace.\n# Note that it returns indices\nfunction update_g(t)\n    T = 100\n    if sin(t/T*2*π) > 0\n        1 # use graph g1\n    else\n        2 # use graph g2\n    end\nend\nmydynamicgraph = DynGraphSpace(g,update_g)\nwholespace = (mydynamicgraph,)\n\n# Definition of birth and death rate\nK0 = 1000 # We will have in total 1000 individuals\nb(X,t) = 1 / nodes\nd(X,Y,t) = (X[1] ≈ Y[1]) / K0\n# Mutation / dispersal parameters\nmu = [1.]\nD = (1.5,)\n# maximum size, tend\nNMax = 2000\ntend = 300.\n# wrapping up all the parameters\np = Dict{String,Any}();@pack! p = D,mu,NMax\n\n# definining world 0 and running\nmyagents = [Agent(wholespace,(5,),ancestors=true,rates=true) for i in 1:K0/nodes]\nw0 = World(myagents,wholespace,p,0.)\n@time sim = run!(w0,Gillepsie(),tend,b,d)","category":"page"},{"location":"examples/gradient.html#Environmental-Gradient","page":"Environmental Gradient","title":"Environmental Gradient","text":"","category":"section"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"In this tutorial, we model agents evolving on a discrete segment, where each patch favours an optimal adaptive trait, along a gradient. This is typically the case along an altitudinal gradient.","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"Here is what the geographical space looks like.","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"(Image: delta_comp_pos)","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"Every colour stands for a different optimal trait.","category":"page"},{"location":"examples/gradient.html#Run-the-world","page":"Environmental Gradient","title":"Run the world","text":"","category":"section"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"using Revise,EvoId,Plots,UnPack\n\n\nnodes = 9\ndim_neutr = 30\ngeospace = DiscreteSegment(Int8(1),Int8(nodes))\nadaptivespace = RealSpace{1,Float16}()\nmyspace = (geospace,adaptivespace)\nsigma_K = 1.;\nsigma_a = .8;\nK0 = 1000;\nmu = [1.,1.]\na = 1\nb(X,t) = gaussian(X[2],X[1] * a,sigma_K) / nodes\nd(X,Y,t) =  (X[1] ≈ Y[1]) * gaussian(X[2],Y[2],sigma_a) / K0\nNMax = 2000\nD = (5e-1,5e-2)\n# tend = 1.5\ntend = 1500\np = Dict{String,Any}();@pack! p = NMax,mu,D\n\nmyagents = [Agent(myspace,(Int8(5),Float16(5) + Float16(5e-2) * randn(Float16),),ancestors=true,rates=true) for i in 1:round(K0/nodes)]\n\nw0 = World(myagents,myspace,p,0.)\n\ns = run!(w0,Gillepsie(),tend,b,d,dt_saving=5);\nPlots.plot(s, ylabel = \"Adaptive trait\",trait=2)","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"(Image: )","category":"page"},{"location":"examples/gradient.html#Animated-trait-space","page":"Environmental Gradient","title":"Animated trait space","text":"","category":"section"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"Here we show how to plot a cool animated scatter plot of the trait space through time.","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"(Image: )","category":"page"},{"location":"examples/gradient.html#lineages","page":"Environmental Gradient","title":"Plotting lineages","text":"","category":"section"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"A cool feature of EvoId.jl is its ability to track agents ancestors traits (cf Agent section)","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"On can plot it, to get an idea of the coalescence of the population.","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"(Image: )","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"Beautiful, isn't it?","category":"page"},{"location":"examples/gradient.html","page":"Environmental Gradient","title":"Environmental Gradient","text":"tip: Making sense of trait histories\nSome metrics are available (cf  Metrics section) that summarize the divergence in trait value (or geographical position) through time).","category":"page"},{"location":"manual/agent.html#Agent","page":"Agent","title":"Agent","text":"","category":"section"},{"location":"manual/agent.html","page":"Agent","title":"Agent","text":"Modules = [EvoId]\nPages   = [\"Agent.jl\"]","category":"page"},{"location":"manual/agent.html#EvoId.Agent-Union{Tuple{S}, Tuple{S}} where S<:Tuple{Vararg{EvoId.AbstractSpace,N} where N}","page":"Agent","title":"EvoId.Agent","text":"Agent(s; ancestors=false)\nAgent(s, pos, Rtype=Float32; ancestors=false)\nAgent(s, pos_t, t, Rtype=Float32; ancestors=false)\n\nReturns an Agent living on the underlying space s  with initial position pos. If pos not provided,  initialises agent with 0 values everywhere\n\nArguments\n\ns\npos\npos_t\nRtype: type of rate. Should correspond to the type \n\nof the output birth and death function for code optimisation.\n\nKeyword arguments\n\nis required for the Gillepsie algorithm, but not for CFM algorithm\n\nancestors. Set ancestors=true when you want to store ancestors traits.\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#EvoId.get_geo-Union{Tuple{X}, Tuple{EvoId.AgentwithAncestors{X,T,R} where R where T,Any}} where X","page":"Agent","title":"EvoId.get_geo","text":"get_geo(a)\n\nReturns geotrait of agent a at time t.\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#EvoId.get_t-Tuple{EvoId.AgentwithAncestors}","page":"Agent","title":"EvoId.get_t","text":"get_t(a)\n\nGet time when agent born.\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#EvoId.get_x-Tuple{EvoId.AgentwithAncestors}","page":"Agent","title":"EvoId.get_x","text":"get_x(a::Agent)\n\nReturns trait i of the agent.\n\n\n\n\n\n","category":"method"},{"location":"manual/agent.html#EvoId.increment_x!-Tuple{EvoId.AgentwithAncestors,Any,Any,Any,Any}","page":"Agent","title":"EvoId.increment_x!","text":"increment_x!(a, s, D, mu, t)\n\nThis function increments (i.e. mutates) agent a according to D, mu. Note: for a::AgentwithAncestors, an extra row is added, since increment_x! is called for birth events after copying the mum traits. Mum traits are therefore Ancestors traits.\n\n\n\n\n\n","category":"method"},{"location":"mathematics/geotrait.html#The-geotrait","page":"The geotrait","title":"The geotrait","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"This note has been taken from 2Y/articles/geotrait/mathematical_notes.md","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"note: 'note' admonition\nIn Landscape Ecology, it is of particular interest to study the geographical position of the lineage through time. This is because richness patterns are thought to arise through allopatric speciation, where populations get separated in space and time. This is the topic of the following section.","category":"page"},{"location":"mathematics/geotrait.html#Julia-accessors","page":"The geotrait","title":"Julia accessors","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"An agents of type Agent{Ancestors{true}} stores the values of its ancestors traits. From it, one can thus study the history of the lineage.","category":"page"},{"location":"mathematics/geotrait.html#Projection-of-the-geographic-history","page":"The geotrait","title":"Projection of the geographic history","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Consider a set of individuals which lineage geographical history has been stored in a vector x^(i)(t). If individual i was born at time t^* then x^(i)(tt^*) represents its geographical position, while x^(i)(tt^*) represents its ancestors geographical position.","category":"page"},{"location":"mathematics/geotrait.html#Isolation-in-time","page":"The geotrait","title":"Isolation in time","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"We want to account for the isolation in time and possibly in space of the lineage of a given individual. That is, for how long and how distant stay lineages appart?","category":"page"},{"location":"mathematics/geotrait.html#Setting","page":"The geotrait","title":"Setting","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Consider a discrete setting, where N(t) individuals (or populations) evolve over a set of M demes disposed in a linear fashion, such that x^i(t) in 12M. The population is characterised by the counting measure","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"nu = sum_i^N(t) delta_x^i(t)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"We define the geographical history hamming distance mathfrakg as","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathfrakhbig(x^(i)(t)x^(j)(t)big) = int_0^t textceil(fracx^(i) - x^(j)(s)M-1)ds","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"We extend this definition with the measure mathfrakh^* which takes into account geographic distance","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathfrakh^*big(x^(i)(t)x^(j)(t)big) = int_0^t Bigx^(i) - x^(j) Big^2(s) ds","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Finally, we introduce the geotrait distance mathfrakg as","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathfrakgbig(x^(i)(t)x^(j)(t)big) = Bigint_0^t (  x^(i) - x^(j) )(s)  dsBig^2","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Note that by the triangle inequality we have that","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathfrakgbig(x^(i)(t)x^(j)(t)big) leq mathfrakh^*big(x^(i)(t)x^(j)(t)big)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Equality should arises if x^(i) x^(j) are positively linearly dependent (which should not be the case).","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"However, what we are eventually interested is a population measure. This measure should be related to the average pairwise distance across the population. Hence we define mathcalD_d(nut) such that","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathcalD_d(nut) = frac12N^2sum_i^N  sum_j^N d(x^(i)x^(j)t)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Let g^(i)(t) = int_0^t x^i(t) dt and G(t) = g^(i)(t) i in 12dotsN(t). By observing the following","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"frac12N^2sum_ij^N (y_i-y_j)^2 =\n frac12N^2sum_ij^N ((y_i-bary) -(y_j-bary))^2 \n = frac12N^2 2N sum_i^N(y_i-bary)^2 = textVar(Y)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Thus we have mathfrakgbig(x^(i)(t)x^(j)(t)big) = g^(i)(t) - g^(j)(t)^2  and hence","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"    mathcalD_mathfrakg(nut) = textVar(G)","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Also  remark that","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"mathcalD_h^*(nut) = frac12N^2sum_i^N  sum_j^N h^*(x^(i)x^(j)t) \n= frac12N^2sum_i^N  sum_j^N  int_0^t Bigx^(i) - x^(j) Big^2(s) ds \n= int_0^t  frac12N^2sum_i^N  sum_j^N  Bigx^(i) - x^(j) Big^2(s) ds \n= int_0^t textVar(X)(s)ds\n","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"One could also imagine a value h^(i)(t) = frac12Nsum_j^N(t)mathfrakh^*big(x^(i)(t)x^(j)(t)big) and in this case we would have","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"    mathcalD_mathfrakh(nut) = frac1Nsum_i^N(t) h^(i)(t)","category":"page"},{"location":"mathematics/geotrait.html#Mobility","page":"The geotrait","title":"Mobility","text":"","category":"section"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"How much do lineages move?","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"Here is a time average of the speed","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"    frac1N sum_i  partial_t x^(i)(t) _t \n    =  frac1N sum_i int_0^t partial_s x^(i)(s) ds \n    = frac1N sum_i x^(i)(t) - x^(i)(0))","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"But one could also have a moving average, that is, averaging","category":"page"},{"location":"mathematics/geotrait.html","page":"The geotrait","title":"The geotrait","text":"    frac1N sum_i sum_j int_jtau^j(tau+1) frac1tau partial_s x^(i)(s) ds","category":"page"},{"location":"notes/comparison.html#Test","page":"Test","title":"Test","text":"","category":"section"},{"location":"notes/comparison.html#Gillepsie","page":"Test","title":"Gillepsie","text":"","category":"section"},{"location":"notes/comparison.html","page":"Test","title":"Test","text":"In Champagnat - HDR Memoire","category":"page"},{"location":"notes/comparison.html","page":"Test","title":"Test","text":"p = 0.1\nK = 1000\nsigm_mut = 0.01\nsigma_alpha = 0.7\nsigma_K = 0.9","category":"page"},{"location":"dev/notes.html#Developping-the-code","page":"Developping the code","title":"Developping the code","text":"","category":"section"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"I recommend to first clone your branch in the directory you like best, and then to develop, you can","category":"page"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"using Pkg\nPkg.dev(\"path_to_EvoId_dir\")","category":"page"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"You can also do the same trick with directly the gitlab address, cf Pkg.jl","category":"page"},{"location":"dev/notes.html#Future-directions","page":"Developping the code","title":"Future directions","text":"","category":"section"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"Fix WF algorithm\nImplement Moran process\nextend the birth function to the form b(X,Y,t) for coherence with death function \nmake mutation and disperal range features of agents, so that they can also evolve.\nSimplify composite type Rates{} parameter for Agents.","category":"page"},{"location":"dev/notes.html","page":"Developping the code","title":"Developping the code","text":"abstract type AbstractAgent{A<:Ancestors,R<:Rates} end","category":"page"},{"location":"manual/plots.html#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"EvoId comes with Plot recipes.","category":"page"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"function plot(sim::Simulation;trait = 1)","category":"page"},{"location":"manual/plots.html#Arguments","page":"Plotting","title":"Arguments","text":"","category":"section"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"if length(trait) == 1 then we scatter plot trait along time\nif 2 <= length(trait) <= 3 then we project world of the last time step in the two  (three) dimensional trait space define by trait","category":"page"},{"location":"manual/plots.html","page":"Plotting","title":"Plotting","text":"warning: To be implemented\nWe might want to get a 3 dimensional scatter plot\nwith time, trait1 and trait2 as axis","category":"page"},{"location":"manual/world.html#World","page":"World","title":"World","text":"","category":"section"},{"location":"manual/world.html","page":"World","title":"World","text":"Modules = [EvoId]\nPages   = [\"World.jl\"]","category":"page"},{"location":"manual/world.html#EvoId.World-Union{Tuple{A}, Tuple{Array{A,1},Tuple{Vararg{EvoId.AbstractSpace,N} where N},Array{T,1} where T,Array{T,1} where T,Real}} where A<:AbstractAgent","page":"World","title":"EvoId.World","text":"World(agents, s, D, mu, NMax; t=0.)\n\nConstructs a world.\n\nArguments\n\nw a vector of agents, \ns a tuple of evolutionary spaces, \nmu a vector that contains the increment rate. If mu[i]   has dimension greater than 1,    then mutations happen independently at each dimension   of s[i].\nD, a vector that contains the increment ranges. Only nothing is    supported for GraphSpace, equivalent to a random walk of length 1.\nNMax the maximum number of individuals allowed during the simulation\n\nExamples\n\n\nnodes = 7\ng = star_graph(nodes)\nlandscape = GraphSpace(g)\nθ = [rand([-1,1]) for i in 1:nodes]\ntraitspace = RealSpace(1)\nevolspace = (landscape,traitspace)\n\nD = [nothing,5e-2]\nmu = [1f-1,1f-1]\np = Dict(\"NMax\" => 2000,\n    \"D\" => D,\n    \"mu\" => mu)\nmyagents = [Agent(evolspace,[rand(1:nodes),randn() * D[2]]) for i in 1:K]\n\nw0 = World(myagents,evolspace,p)\n\n\n\n\n\n","category":"method"},{"location":"manual/world.html#Base.getindex-Tuple{World,Any}","page":"World","title":"Base.getindex","text":"Base.getindex(w::World,i)\n\nGet x of world without geotrait.\n\n\n\n\n\n","category":"method"},{"location":"manual/world.html#EvoId.get_geo-Tuple{World}","page":"World","title":"EvoId.get_geo","text":"get_geo(w)\n\n\n\n\n\n","category":"method"},{"location":"manual/world.html#EvoId.get_x-Tuple{World,Any}","page":"World","title":"EvoId.get_x","text":"get_x(w, trait)\n\n\nReturns trait of every agents of world in the form of an array which dimensions corresponds to the input. If trait = 0 , we return the geotrait.\n\nwarning: Warning\nGeotrait might be deprecated in the future.\n\n\n\n\n\n","category":"method"},{"location":"manual/world.html#EvoId.get_xarray","page":"World","title":"EvoId.get_xarray","text":"get_xarray(world)\nget_xarray(world, geotrait)\n\n\nReturns every traits of every agents of world in the form of a one dimensional array (in contrast to get_x). If geotrait=true the geotrait is also added to the set of trait, in the last column. If you do not want to specify t (only useful for geotrait), it is also possible to use get_xarray(world::Array{T,1}) where {T <: Agent}.\n\nwarning: Warning\nIt does not work with subspace where ndims(subspace) > 1.\n\n\n\n\n\n","category":"function"},{"location":"manual/world.html#EvoId.give_birth-Tuple{Int64,World}","page":"World","title":"EvoId.give_birth","text":"give_birth(mum_idx::Int,w::World)\n\nCopies agent within index mum_idx, and increment it by dx. Return new agent (offspring).\n\n\n\n\n\n","category":"method"},{"location":"manual/run_world.html#Run-the-World","page":"Run the World","title":"Run the World","text":"","category":"section"},{"location":"manual/run_world.html","page":"Run the World","title":"Run the World","text":"run!","category":"page"},{"location":"manual/run_world.html#EvoId.run!","page":"Run the World","title":"EvoId.run!","text":"run!(w, alg, tend, b, d; dt_saving=nothing, cb=(names = String[],agg =nothing))\n\nRun w with algorithm alg, until tend is reached. User needs to provide b the birth function, which takes as arguments X,t, and provide d the death function, with arguments X,Y,t. The run stops if the number of agents reachesp[\"NMax\"], where p is the parameter dictionary in the world w.\n\nReturns a Simulation object. It is a container for snapshots of the world at every dt_saving  time steps. It renders post processing easier, through dedicated methods to obtain time series of quantities.\n\nKeyword arguments\n\nif dt_saving specified, world is saved every time steps.\n\nIf dt_saving not specified, sim contains an array of two elements, first corresponding to initial conditions and last corresponding to world in the last time step.\n\nif t_saving_cb specified, callbacks are computed at each steps time specified in the array.\n\nThis functionality is as of now only compatible with dt_saving not specified.\n\ncb correspond to callbacks function. Callbacks can be used \n\nto extract properties of the world at each dt_saving time steps of your simulation.\n\nConstructing the callbacks\n\nA callback has to be of the form\n\ncb = (names = String[], agg = Function[])\n\nIt is a tuple, with first value corresponding to the names of the aggregate properties of the world. The second correspond to the aggregation functions.\n\nWe provide here an example on how to extract the gamma diversity of a simulation biological population.  gamma` diversity can be calculated as the variance of the trait distribution of the population. Here is how we write the function\n\ncb = (names = [\"gamma_div\"], agg = Function[w -> var((get_x(w,1)))])\n\nExample\n\nmyspace = (RealSpace{1,Float64}(),)\nsigma_K = .9;\nsigma_a = .7;\nK0 = 1000;\nb(X) = gaussian(X[1],0.,sigma_K)\nd(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0\nD = (1e-2,)\nmu = [.1]\nNMax = 10000\ntend = 1.5\np = Dict{String,Any}();@pack! p = D,mu,NMax\n\nmyagents = [Agent(myspace,(0,),ancestors=true,rates=true) for i in 1:K0]\nw0 = World(myagents, myspace, p, 0.)\nw1 = copy(w0)\nsim = run!(w1,Gillepsie(),tend,b,d,cb=cb,dt_saving = .1)\n\nAccessing the callbacks\n\nYou can easily access the properties, using sim as you would for a usual Dictionary.\n\nusing Plots\nplot(get_tspan(sim),sim[\"gamma_div\"])\n\n\n\n\n\n","category":"function"},{"location":"manual/run_world.html","page":"Run the World","title":"Run the World","text":"For now three algorithms","category":"page"},{"location":"manual/run_world.html","page":"Run the World","title":"Run the World","text":"Gillepsie\nCFM\nWF","category":"page"},{"location":"manual/run_world.html#EvoId.Gillepsie","page":"Run the World","title":"EvoId.Gillepsie","text":"struct Gillepsie <: EvoId.AbstractAlg\n\nGillespie algorithm.\n\nDenote by b_i and d_i the birth and death rates of  agent i. The total rate is given by the sum of all individual rates R(t) = left sum_i b_i(t) + d_i(t) right. A particular event, birth or death,  is chosen at random with a probability equal to the rate of this event divided by the total rate R.\n\nThe original article by Gillsepie:\n\nA general method for numerically simulating the stochastic  time evolution of coupled chemical reactions\n\n\n\n\n\n","category":"type"},{"location":"manual/run_world.html#EvoId.CFM","page":"Run the World","title":"EvoId.CFM","text":"struct CFM <: EvoId.AbstractAlg\n\nChampagnat Ferriere Méléard algorithm described in  Champagnat and Ferriere founding article.  This algorithm is similar to Gillepsie, excepts that it runs faster for higher number of individuals.\n\nIndeed, at every time step, only the fitness of the individual picked at random is evaluated.  In order to use it, you need to feed to the dictionary parameters  p a constant Cbar<:Real that is  the upperbound of the maximum of the sum of the birth and death rates (cf article).\n\nExample\n\nusing EvoId,UnPack,Plots\nmyspace = (RealSpace{1,Float64}(),)\nσ_b = .9;\nσ_d = .7;\nK0 = 1000\nb(X,t) = 1.\nd(X,Y,t) = gaussian(X[1],Y[1],σ_d)/K0 / gaussian(X[1],0.,σ_b)\nCbar = b([0],0.) + d([0],[0],0.)\nD = (1e-2,)\nmu = [.1]\nNMax = 2000\ntend = 1500\np = Dict{String,Any}();@pack! p = D,mu,NMax,Cbar\nmyagents = [Agent(myspace,(1e-2 * randn(),)) for i in 1:K0]\nw0 = World(myagents,myspace,p,0.)\n@time sim = run!(w0,CFM(),tend, b, d, dt_saving = 4)\n\nwarning: Development\nCFM gives an approximate time step. As of now, we do not manage to obtain qualitatively the same results as the Gillepsie algorithm.\n\nAlgorithm described in article DOI : 10.1016/j.tpb.2005.10.004\n\n\n\n\n\n","category":"type"},{"location":"manual/run_world.html#EvoId.WF","page":"Run the World","title":"EvoId.WF","text":"struct WF <: EvoId.AbstractAlg\n\nWright Fisher algorithm.\n\nIn the Wright Fisher process the number of agents is constant through time. It is helpful to visualize it through marbles in jar (Image: alt text) At each time step, N agents are picked up from previous generation to reproduce.  Their number of offspring is proportional to their fitness, calculated as usual with birth and death rates. It takes thus only one time step to go trough one generation. Thus it is more suitable for numerical simulations than CFM or Gillespie. \n\n\n\n\n\n","category":"type"},{"location":"manual/run_world.html","page":"Run the World","title":"Run the World","text":"Warning : WF not implemented yet","category":"page"},{"location":"manual/space.html#Space","page":"Space","title":"Space","text":"","category":"section"},{"location":"manual/space.html","page":"Space","title":"Space","text":"Modules = [EvoId]\nPages   = [\"Space.jl\"]","category":"page"},{"location":"manual/space.html#EvoId.ContinuousSegment","page":"Space","title":"EvoId.ContinuousSegment","text":"ContinuousSegment(s, e)\n\nCreates a segment space, where individuals are reflected at both ends.\n\nArguments\n\ns start of the segment\ne end of the segment\n\nExample\n\nContinuousSegment(1., 2.)\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#EvoId.DiscreteSegment","page":"Space","title":"EvoId.DiscreteSegment","text":"DiscreteSegment(s, e)\n\nCreates a discrete segement space, where individuals are reflected at both ends.\n\nArguments\n\ns start of the segment\ne end of the segment\n\nExample\n\n    DiscreteSegment(1, 2)\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#EvoId.GraphSpace","page":"Space","title":"EvoId.GraphSpace","text":"GraphSpace(g)\n\nCreates a Graph Space.\n\nExample\n\nusing LightGraphs\ng = star_graph(7)\nGraphSpace(g)\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#EvoId.NaturalSpace","page":"Space","title":"EvoId.NaturalSpace","text":"NaturalSpace{N,T}\n\nA natural space with dimension N and type T\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#EvoId.RealSpace","page":"Space","title":"EvoId.RealSpace","text":"RealSpace{N,T}()\n\nCreates a real space.\n\nArguments\n\nN dimension of the space \nT type of the underlying traits.\n\n\n\n\n\n","category":"type"},{"location":"manual/space.html#EvoId.get_graph-Tuple{DynGraphSpace,Any}","page":"Space","title":"EvoId.get_graph","text":"get_graph(d, t)\n\nReturns the graph correseponding to d::DynGraphSpace at time t\n\n\n\n\n\n","category":"method"},{"location":"manual/space.html#EvoId.get_inc-Tuple{Any,Any,EvoId.AbstractStatSpace,Any}","page":"Space","title":"EvoId.get_inc","text":"get_inc(x, D, s)\n\nReturns increment corresponding to space s\n\n\n\n\n\n","category":"method"},{"location":"examples/delta_competition_example.html#A-first-model-of-meta-population","page":"A first model of meta population","title":"A first model of meta population","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"In this script, we model the evolution of a population where agents are simply defined by their position on some landscape. We implement the simplest possible birth and death function.","category":"page"},{"location":"examples/delta_competition_example.html#The-landscape","page":"A first model of meta population","title":"The landscape","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"Let's start by a linear landscape. We define a discrete segment of length 9, with reflecting boundary conditions. In fact, reflecting boundary conditions are implemented for any finite space.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"warning: 1D Reflections\nAs of v1, only reflections on one dimensional space are implemented. We have a two dimensional reflection method that will be released in the future.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"There are two ways of implementing a linear landscape. The first one uses a DiscreteSegment while the second relies on LightGraphs.jl library. Both are almost equivalent.","category":"page"},{"location":"examples/delta_competition_example.html#DiscreteSegment","page":"A first model of meta population","title":"DiscreteSegment","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"using EvoId\nnodes = 10\nmysegment = DiscreteSegment(1,nodes)\nwholespace = (mysegment,)","category":"page"},{"location":"examples/delta_competition_example.html#grid","page":"A first model of meta population","title":"grid","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"using EvoId, LightGraphs\nnodes = 10\ng = grid([nodes,1])\nmysegmentgraph = GraphSpace(g)\nwholespace = (mysegmentgraph,)","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"warning: Space tuple\nNotice that the whole space should be a tuple of spaces. Even where there is only one sub vector space as here, you need to have brackets and comma around the unit vector space.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"Here is how you can visualise the landscape.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"using GraphPlot\ngplot(g, collect(1:nodes), collect(1:nodes))","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"(Image: delta_comp_pos)","category":"page"},{"location":"examples/delta_competition_example.html#Defining-competition-processes","page":"A first model of meta population","title":"Defining competition processes","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"We propose that any individual have a constant birth rate, and competes with all the individuals present in the same patch. Assume there are N_t individuals at time t. Let i in  12dotsN_t. x_i in 12dots9 denotes the position of the i-th individual. The competition pressure experienced by individual i is such that","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"d(x_it) = sum_j^N(t) delta(x_i-x_j)","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"where delta is the dirac function.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"In this way, we recover a logistic growth function for subpopulation within a patch.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"K0 = 1000 # We will have in total 1000 individuals\nb(X,t) = 1 / nodes\nd(X,Y,t) = (X[1] ≈ Y[1]) / K0","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"At equilibrium, population size in each deme will reach K0 / nodes.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"warning: Time dependency\nEven though time is not used, you have to write birth and death functions with time dependency.","category":"page"},{"location":"examples/delta_competition_example.html#Dispersal","page":"A first model of meta population","title":"Dispersal","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"We assume that anytime an offspring is born, it is given a chance to move (\\mu = 1).","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"mu = [1.]\nD = (1.5,)","category":"page"},{"location":"examples/delta_competition_example.html#Running-the-world","page":"A first model of meta population","title":"Running the world","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"We initialise the world with initial population of size K_0  9 located on patch 5. NMax corresponds to the maximum number of individuals that can be attained. If attained, then the programm stops. We keep track of individuals' ancestors by setting ancestors=true. Because we wish to use Gillepsie algorithm, we need rates=true as agents' internal birth and death rates are updated at every time step.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"note: Warning\nrates treatment is something we might implement in the library internals.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"using UnPack# useful macro @pack!\nNMax = 2000\ntend = 300.\np = Dict{String,Any}();@pack! p = D,mu,NMax\nmyagents = [Agent(myspace,(5,),ancestors=true,rates=true) for i in 1:K0/nodes]\nw0 = World(myagents,myspace,p,0.)\n@time sim = run!(w0,Gillepsie(), b, d, tend)","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"This is the simplest run you can do. Now is time for more interesting things","category":"page"},{"location":"examples/delta_competition_example.html#Analysis","page":"A first model of meta population","title":"Analysis","text":"","category":"section"},{"location":"examples/delta_competition_example.html#Size-of-the-world","page":"A first model of meta population","title":"Size of the world","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"Let's verify that the population's growth is logistic. We will plot the population size over time. To do so, one need to define dt_saving < tend to save every dt_saving time steps of the world.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"wsize = [length(w) for w in sim[:]]\nusing Plots\nPlots.plot(get_tspan(sim),wsize,\n                label = \"\",\n                ylabel = \"Metapopulation size\",\n                xlabel =\"time\",\n                grid = false)","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"(Image: )","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"notes: Callbacks\nNote that one could also use a callback function to obtain time series of size of the world computed at simulation time. See Callbacks page.","category":"page"},{"location":"examples/delta_competition_example.html#Position-through-time","page":"A first model of meta population","title":"Position through time","text":"","category":"section"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"One might be tempted to plot the agents position for some time steps.","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"Plots.plot(sim,\n        label = \"\",\n        ylabel = \"Geographical position\",\n        grid = false,\n        markersize = 10)","category":"page"},{"location":"examples/delta_competition_example.html","page":"A first model of meta population","title":"A first model of meta population","text":"(Image: delta_comp_pos)","category":"page"},{"location":"mathematics/mathematical_foundations.html#Mathematical-foundations","page":"Mathematical foundations","title":"Mathematical foundations","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Dieckmann and Law (probably more accessible than following), and then\nNicolas, Ferriere and Meleard","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"showed that the canonical equations of adaptive dynamics, describing the evolution in the phenotypic space, can be derived by considering the stochastic individual-based model corresponding to","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"partial_t u(tx) = u(tx)(1-fracint alpha(xy) u(yt) dyK(x))\ntag1","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"in the limit of rare mutations, small mutational effects, and infinite population sizes.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Under these assumptions, Dieckmann and Law showed that adaptive dynamics is the first-order approximation of the mean path averaged over infinitely many realizations of the stochastic simulations obtained from the individual-based model.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"[[TOC]]","category":"page"},{"location":"mathematics/mathematical_foundations.html#The-basics-of-Adaptive-Dynamics","page":"Mathematical foundations","title":"The basics of Adaptive Dynamics","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"This section is inspired from Adaptive Diversification, Doebeli 2011","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Imagine a monomorophic population with trait x, which follows the dynamics","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"partial_t u(tx) = u(tx)bigb(x) - c(x)u(tx)big","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Logistic models are thought to be mathematically representative of a large class of models (During2008) :smirk:. Doebeli \"Chaos\" paper might also be relevant for this purpose","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Equilibrium is given by u^*(x) equiv K(x) = b(x)c(x). Hence one can reformulate equation above by","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    partial_t u(tx) = u(tx) left(b(x) - fracb(x)u(tx)K(x)right )","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Adaptive dynamics aims at determining the evolutionary trajectory of the trait x by considering the fate of rare mutants with traits y in resident monomorphic population with trait x. The resident population is assumed to be at equlibrium K(x). Because mutant is rare, the mutant's population dynamics is only affected by the density of the resident, which in turn is unaffected by the mutant's invasion attempt, and hence remains at K(x). Hence the effective density that mutant experiences during invasion attempt is detrmined by alpha(xy)K(x). The function  alpha is the competition kernel and describes the strength of competition that exerts the phenotype x on phenotype y.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"For our purpose, we consider it as symmetric, which corresponds to the canonical biological examples of birds with different beak size. We think this is also valid for plants, and in general along a genus.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"It is assumed that alpha(xx) = 1 (scaled to unity).","category":"page"},{"location":"mathematics/mathematical_foundations.html#Stabilising-selection","page":"Mathematical foundations","title":"Stabilising selection","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Stabilising selection ensures that trait x is contained, thus avoiding regions of extreme trait values that would be biologically unrealistic. It can appear by limiting birth rate b(x) or increasing death rate c(x) for extreme x","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Now we can determine the population dynamics of a mutant with population size N_mut and trait y experiencing the effective density N_eff = alpha(xy)K(x)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"beginaligned\n    fracpartial N_mutpartial x(tx) = N_mut(b(y) - c(y)N_eff)\n    = N_mut(b(y) - c(y) alpha(xy)K(x))\n    = N_mut(b(y) - fracb(y) alpha(xy)K(x)K(y))\nendaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html#Invasion-fitness","page":"Mathematical foundations","title":"Invasion fitness","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The invasion fitness f(xy) corresponds to the fitness of a mutant with traits y in a resident monomorphic population with trait x","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"beginaligned\n    f(xy) = frac1N_mutfracpartial N_mutpartial t  = left( b(y) - c(y)N_eff right)\n    iff \n    f(xy) = b(y)left( 1 - fracalpha(xy)K(x)K(y) right)\nendaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":gun: Plot the fitness function in the case of the EvoId","category":"page"},{"location":"mathematics/mathematical_foundations.html#Canonical-equation-for-the-Adaptive-Dynamics","page":"Mathematical foundations","title":"Canonical equation for the Adaptive Dynamics","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"fracd xd  t = m(x) D(x)  tag2","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"You should write it in the multidimensional case","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"D(x) = fracpartial f(xy)partial yBig_y=x is called the selection gradient\nm(x) is the mutational kernel. In Champagnat2011, it is denoted as m(x) = mu(x)  fracsigma_0^2(x)2  N(x) where mu denottes the probability that a birth from an individual with trait x gives rise to a mutation. sigma_0^2(x) denotes the variance of the distribution of a mutant trait y born from an individual with trait x. Even if the mutational effect is independent of x, the rate at which new mutations occur depends on the current population size N(x). If population is monomorphic, m only scales time. However, when population becomes polymorphic, mutation affects evolutionary dynamics.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":question:Essentially, adaptive dynamics is a first order approximation of the nonlinear dynamics of any evolutionary model","category":"page"},{"location":"mathematics/mathematical_foundations.html#Symmetric-competition-kernels","page":"Mathematical foundations","title":"Symmetric competition kernels","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Here we assume that b(x) = b in R and c(x) = bK(x). Thus the canonical equation for adaptive dynamics yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    fracd xd  t = bleft( alpha(xy)frac K (x)K(x) - partial_2 alpha(xy) right)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Assuming that alpha(xy) = alpha(x-y) and maximum competition at 0, we have that partial_2 alpha(xx) = 0 and thus","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    fracd xd  t = b  alpha(xy)frac K (x)K(x)","category":"page"},{"location":"mathematics/mathematical_foundations.html#:heart:-Evolutionary-singularities:-D(x*)-\\partial_2-f(x*,x*)-0","page":"Mathematical foundations","title":":heart: Evolutionary singularities: D(x^*) = partial_2 f(x^*x^*) = 0","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The fixed points of equation (2) are the points where the fitness gradient nullifies, and are called evolutionary singularities.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In this special case, the monomorphic population evolutionary dynamics is only driven by carrying capacity. Assuming a unimodal carrying capacity, the adaptive dynamics will always converge to the maximum of K(x)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":question: This can be made explicit using the concept of singular points and convergence stability","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":rocket: unimodality of K(x) implies the existence of a unique singular point at the trait value maximising the carrying capacity","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"","category":"page"},{"location":"mathematics/mathematical_foundations.html#:heart:-Convergence-stability:-D'(x*)-0","page":"Mathematical foundations","title":":heart: Convergence stability: D(x^*)  0","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Convergence stability of the singular point is determined by the quantity D(x^*)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Because x^* is a maximum, we have D(x^*) = bfracK(x)K(x)  0 hence the singular point is always convergence stable.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"By definition, selection vanishes at the singular point. Therefore, after convergence, second order effects of selection come at play, which is why the competition kernel and hence frequency dependence starts to be important.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In a d dimensional setting, convergence stability is obtained if the Jacobian matrix of the set of ODE (2) has all its eigenvalues negative at the singular point x^*.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":warning: in a multidimensional space, convergence stability nor being in the neihborhood of a singular point are required for evolutionary branching to occur.","category":"page"},{"location":"mathematics/mathematical_foundations.html#:heart:-Evolutionary-branching-point:-\\partial_{22}f(x*,x*)-0","page":"Mathematical foundations","title":":heart: Evolutionary branching point: partial_22f(x^*x^*)  0","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In 1D, convergent stable singular point is either a maximum of minimum of the invasion fitness function. Note that for any y neq x^*, alpha(x^*y)alpha(x^*x^*) and K(y)K(x^*).","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":rocket: Whether x^* can be invaded by a mutant depends on the relative magnitude of these two effects, which in turns is determined by the curvature of the competition kernel and carrying capacity.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In our particular case we have","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"partial_22f(x^*x^*) = b left(fracK(x^*) K(x) - alpha(x^*x^*) right)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Hence we get that x^* is a fitness minimum, i.e. an evolutionary branching pointiff","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"alpha(x^*x^*)fracK(x^*) K(x)","category":"page"},{"location":"mathematics/mathematical_foundations.html#Reminder:","page":"Mathematical foundations","title":"Reminder:","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"(Image: Alt Text)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: in dimension D, the condition for minima is obtained by the determinant of the Hessian (The second partial derivative test)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Note that if  K(x) = exp(-frac(x-x_0)^22sigma_K^2) and alpha(xy) = exp(-frac(x-y)^22sigma_alpha^2)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"then above condition boils down to","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    sigma_alpha  sigma_K","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The Appendix of Doebeli2011 demonstrates from general dynamic systems theory that phenotypes x_1 and x_2 can coexist if they are close enough to the singular point.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Taylor-expansion-of-the-fitness-function","page":"Mathematical foundations","title":"Taylor expansion of the fitness function","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html#D","page":"Mathematical foundations","title":"1D","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Let's expand the fitness function for a scalar trait","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    f(xy) = f(xx) + partial_2 f(xx)(y-x) + partial_22 f(xx)frac(y-x)^22 + dots","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"First term is 0 for all x. The second term vanishes at the singular point, which is where the second order term come at play. If partial_22 f(x^*x^*) 0 no nearby mutants can invade the resident population that is monomorphic and thus conditions for evolutionary stability are obtained.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In contrast, partial_22f(x^*x^*)  0 is the condition for evolutionary instability, or potential evo- lutionary branching points, as the mutant now can potentially invade the resident.","category":"page"},{"location":"mathematics/mathematical_foundations.html#D-2","page":"Mathematical foundations","title":"2D","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    f(xy) = f(xx) + nabla_2 f(xx)(y-x) + frac12(y-x)^T nabla_2^2 f(xx) (y-x) + dots","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"We refer to nabla_2^2 f(xx) equiv H(x) as the hessian matrix.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"In this scenario, the first-order term can become zero or be arbitrarily close to zero when the vector y-z is orthogonal or nearly orthogonal to the gradient nabla_2 f(xx). In other words, the second-order terms for trait values y that lie orthogonal to the direction of the gradient of f(x, y) become significant regardless of whether or not the trajectory is in the vicinity of a singular point. In particular, if H(x)is negative definite, no nearby mutants can invade the resident population that is monomorphic and we have the conditions for evolutionary stability.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: When the Hessian matrix has an eigenvector with a positive eigenvalue and this eigenvector has a nonzero projection in the subspace orthogonal to the direction of the selection gradient, we get the condition for evolutionary instability. The mutants from these directions can potentially invade the resident. Geometrically, the Hessian matrix at a particular point determines the local curvature of the level set of the function f(x y) as a function of y passing through that point. Depending on this curvature (the non- negativity of the Hessian matrix), there may exist directions along which the invasion fitness function has a minimum with respect to the mutant trait values and hence becomes evolutionary unstable.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Determining-the-dimorphic-steady-state:-D({\\bf-x})-D(x_1,x_2)-\\begin{pmatrix}D_1(x_1,x_2)-\\\\-D_2(x_1,x_2)\\end{pmatrix}-\\begin{pmatrix}\\partial_3f(x_1,x_2,x_1)\\\\\\partial_3f(x_1,x_2,x_2)-\\end{pmatrix}-{\\bf-0}","page":"Mathematical foundations","title":"Determining the dimorphic steady state: D(bf x) = D(x_1x_2) = beginpmatrixD_1(x_1x_2)  D_2(x_1x_2)endpmatrix = beginpmatrixpartial_3f(x_1x_2x_1)partial_3f(x_1x_2x_2) endpmatrix = bf 0","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Consider mutants in the dimorphic population (x_1x_2). Ecological dynamics yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    beginaligned\n        partial_t N_1 = bN_1(1-fracN_1 + alpha(x_1x_2)N_2K(x_1)) \n        partial_t N_2 = bN_2(1-fracN_2 + alpha(x_1x_2)N_1K(x_2))\n    endaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Equilibrium densities are given by","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    beginaligned\n    N_1^* = N_2^* = fracexpleft(x_1^2left( frac2sigma_alpha^2 - frac12sigma_K^2 right)right)1+expleft(frac2x_1^2sigma_alpha^2right)\n    endaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Hence invasion fitness in the dimorphic population (x_1x_2) is","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    f(x_1x_2y) =bleft(1 - fracleft( alpha(x_1y)N_1^* + alpha(x_2y)N_2^*right)K(y)right)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Thus the selection gradient in the resident x_1 yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    beginaligned\n    D_1(x_1x_2) = partial_3f(x_1x_2x_1)\n    = dots\n    endaligned","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The 2-dimensional adaptive dynamics systems yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    fracd bf xdt = m(bf x)D(bf x)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"where the mapping m colon R^2 toR^2 decsribes the mutational process in the two resident strains.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"look Appendix Doebeli2011 that deals with mutations","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"With symmetric Gaussian competition we get","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    x_1^* = x_2^* = sqrtlnleft(frac2sigma_K^2sigma_alpha^2 - 1right)fracsigma_alpha^22","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":gun: This is a good way to check that your IBM is working!!!","category":"page"},{"location":"mathematics/mathematical_foundations.html#Convergence-stability-of-the-dimorphic-state:-J_D(x_1*,x_1*)","page":"Mathematical foundations","title":"Convergence stability of the dimorphic state: J_D(x_1^*x_1^*)","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"If the eigenvalues of the Jacobian matrix J_D(x_1^*x_1^*)are negative, then after after evolutionary branching the two phenotypic branches converge to x_1^* and x_2^*.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Evolutionary-branching-of-the-dimorphic-state","page":"Mathematical foundations","title":"Evolutionary branching of the dimorphic state","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":flushed: because of the symmetry assumption the two singular strategies either both represent local maxima or minima for the invasion fitnessfunction. It can be shown that whenever sigma_alphasigma_K both singular strategies are fitness minima, hence evolytionarily unstable.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Behaviour-in-deep-time","page":"Mathematical foundations","title":"Behaviour in deep time","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Evolutionary branching continues ad infinitum, that is when time goes to inifinity there is infinitely many branches with decreasing population starting from carrying capacity maximum. This is a peculariaty of the Gaussian kernel. Hence the popupulation will simply be polymorphic, normally distributed. This is what we observe from our PDE model.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: Doebeli2011 claims that Gaussian ecological functions in stochastic IBM for finite populations typically leads to only a small number of successive events","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: This is why it makes sense to extend this work to a continuous setting.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Quadratic-carrying-capacity","page":"Mathematical foundations","title":"Quadratic carrying capacity","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Competition kernel is still assumed gaussian. Now","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    K(x) = 1-ax^2","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Conditions for the singular point to be an evolutionary branching point yields","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"    sigma_alpha  frac1sqrt2a","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Not possible to get explicit expression for the singular coalition of the two dimensional dynamics, but one can give examples and solve it numerically. The coexisting strategies are evolutionary stable as long as sigma_alpha is not too small. For example, take","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"a= 0.125","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Evolutionary stability is obtained for 125  sigma_alpha  2","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":flushed: also important to note that even if the coexisting points are not convergent stable the four dimensional adaptive dynamics can have a singular coalition in which all strains are evolutionary stable.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":exclamation: This proves that even if frequency dependent is strong enough to induce diversification, it noes not necessarily lead to an infinite series of subsequent branching events.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":":gun: We made the simulation for the corresponding PDE, and this is what we get (Image: Alt Text) Note that is proves to be a stiff problem when mu neq 0","category":"page"},{"location":"mathematics/mathematical_foundations.html#Derive-the-particular-case-for-Eq.-(1)","page":"Mathematical foundations","title":"Derive the particular case for Eq. (1)","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html#Particular-case-of-the-logistic-map","page":"Mathematical foundations","title":"Particular case of the logistic map","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"At equilibrium, the monomorphic resident population is distributed along the resource such that  u(tx) = K(x) since we consider that alpha(xx) = 1.","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"This is different for mutator selector equation, but you should check it\nAlso check it with varying birth rate, as Champagnat example","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Invasion fitness for the logistic map, of a rare mutant y is its per capital rate of growth in a resident population with phenotype x and is given by","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":" f(xy) = left(1-fracalpha(xy)K(x)K(y) right)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Indeed","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"This has to be checked","category":"page"},{"location":"mathematics/mathematical_foundations.html#Competition-and-resource-Kernel","page":"Mathematical foundations","title":"Competition and resource Kernel","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Evolutionary dynamics from deterministic microscopic ecological processes shows that adding a power to the kernels does not modify the adaptive dynamics evolutionary trajectories. It just accelerates its rates.\nThe shape of the competition and carrying capacity kernels affects the likelihood of disruptive selection presents alternative functional forms for competition and resource kernels, and investigate its impact on diversification. Box-like kernel can facilitate evolutionary branching.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Conditions-for-diversification","page":"Mathematical foundations","title":"Conditions for diversification","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Under the dynamics above, we have that adaptive diversification happen under the condition","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"fracpartial^2 f partial x^2(xy)","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"This is also tackled in Champagnat's memoire is Section 1.4.3, with example in Section 1.2.2.","category":"page"},{"location":"mathematics/mathematical_foundations.html#Mutation","page":"Mathematical foundations","title":"Mutation","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Here we discuss how we can introduce mutation in Eq. (1) so that we obtain","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"partial_t u(tx) = u(tx)(1-fracint alpha(xy) u(yt) dyK(x)) + Delta_x u(tx)\ntagmutations","category":"page"},{"location":"mathematics/mathematical_foundations.html#Correspondance-with-Individual-Based-Model","page":"Mathematical foundations","title":"Correspondance with Individual  Based Model","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"The Canonical Equation of Adaptive Dynamics: A Mathematical View has derived for the first time canonical expression from first principles, based on taking limits of a jump process","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"inifinite population\nmutation are very rare, that is ecological and evolutionary timescales are separated.","category":"page"},{"location":"mathematics/mathematical_foundations.html#References","page":"Mathematical foundations","title":"References","text":"","category":"section"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"A very good introduction in Adaptive Dynamics on Wikipedia (in French):","category":"page"},{"location":"mathematics/mathematical_foundations.html","page":"Mathematical foundations","title":"Mathematical foundations","text":"Dynamique Adaptive ","category":"page"},{"location":"mathematics/minimal_abm.html#Minimal-individual-based-model","page":"Minimal individual based model","title":"Minimal individual based model","text":"","category":"section"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"There are infinitely many invasion fitness functions with different competition kernels that give the same adaptive dynamics.","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Madhok2020 describes the minimal competition kernel","category":"page"},{"location":"mathematics/minimal_abm.html#Minimal-individual-based-model-2","page":"Minimal individual based model","title":"Minimal individual based model","text":"","category":"section"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Described from Ispolatov et al. 2016 (cf references). Adaptive dynamics is written as","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"    dotx_i = ((nabla_y alpha)(xx))_i + ((nabla_x ln(K))(x))_i = w_i(x) + u_i(x)","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"It is assumed a standard carying capacity of the form","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"    K(x) = exp(-x^44)","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"The minimal competition kernel is defined as","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"alpha(xy) = expleft(sum_i w_i(x)(x_i-y_i) right)","category":"page"},{"location":"mathematics/minimal_abm.html#Gaussian-competition-kernel-and-adaptive-diversification","page":"Minimal individual based model","title":"Gaussian competition kernel and adaptive diversification","text":"","category":"section"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Consider","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"alpha(xu) = expleft( sum_i w_i(x) (x_i-y_i)+frac(x_i-y_i)\n^22sigma_i^2right)","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Which has Hessian matrix","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"fracpartial^2 fpartial y_i partial y_j(xy) = -w_i(x)w_j(x) + w_j(x) x_i^3 - 2 x_i^3x_j^3 - left(3 x_i^2 - frac1sigma_i^2 right) delta_ij","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"This Hessian matrix can possess positive eigenvalues depending on the variance of the Gaussian components sigma_i and the coordinates in the phenotypic space.","category":"page"},{"location":"mathematics/minimal_abm.html#References","page":"Minimal individual based model","title":"References","text":"","category":"section"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Evolutionary dynamics from deterministic microscopic ecological processes","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"This paper proposes a new deterministic way of running an IBM. The nice thing about it is that it is still compatible with the canonical equation of adaptive dynamics, and runs faster than other models.","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"Individual-based models for adaptive diversification in high-dimensional phenotype spaces","category":"page"},{"location":"mathematics/minimal_abm.html","page":"Minimal individual based model","title":"Minimal individual based model","text":"This paper provides a method to construct individual-based models such that they faithfully reproduce the given adaptive dynamics attractor without diversification - cf the minimal competition kernel. It then shows that a propensity to diversify can be introduced by adding Gaussian competition terms that generate frequency dependence while still preserving the same adaptive dynamics. For sufficiently strong competition, the disruptive selection generated by frequency-dependence overcomes the directional evolution along the selection gradient and leads to diversification in phenotypic directions that are orthogonal to the selection gradient.","category":"page"},{"location":"examples/sympatric_speciation.html#Modelling-Sympatric-speciation","page":"Modelling Sympatric speciation","title":"Modelling Sympatric speciation","text":"","category":"section"},{"location":"examples/sympatric_speciation.html","page":"Modelling Sympatric speciation","title":"Modelling Sympatric speciation","text":"This script aims at reproducing the 1999 article of Doebeli On The Origin of Species By Sympatric Speciation.","category":"page"},{"location":"examples/sympatric_speciation.html","page":"Modelling Sympatric speciation","title":"Modelling Sympatric speciation","text":"In this article, birth and death functions are defined as gaussian, with respective variance sigma_b and sigma_d. It is shown that when sigma_d  sigma_b, speciation in the trait space occurs. This is what we reproduce here.","category":"page"},{"location":"examples/sympatric_speciation.html#Running-the-world","page":"Modelling Sympatric speciation","title":"Running the world","text":"","category":"section"},{"location":"examples/sympatric_speciation.html","page":"Modelling Sympatric speciation","title":"Modelling Sympatric speciation","text":"We need to run the simulation for a significant amount of time to observe sympatric speciation. As such, we set ancestors=false. The rest is pretty standard","category":"page"},{"location":"examples/sympatric_speciation.html","page":"Modelling Sympatric speciation","title":"Modelling Sympatric speciation","text":"myspace = (RealSpace{1,Float64}(),)\nσ_b = .9;\nσ_d = .7;\nK0 = 1000\nb(X,t) = 1.\nd(X,Y,t) = gaussian(X[1],Y[1],σ_d)/K0 / gaussian(X[1],0.,σ_b)\nD = (1e-2,)\nmu = [.1]\nNMax = 2000\ntend = 1500\np = Dict{String,Any}();@pack! p = D,mu,NMax\nmyagents = [Agent(myspace,(1e-2 * randn(),),rates=true) for i in 1:K0]\nw0 = World(myagents,myspace,p,0.)\n@time sim = run!(w0,Gillepsie(),tend,b,d,dt_saving = 10)\nPlots.plot(sim, ylabel = \"Adaptive trait\")","category":"page"},{"location":"examples/sympatric_speciation.html","page":"Modelling Sympatric speciation","title":"Modelling Sympatric speciation","text":"(Image: )","category":"page"},{"location":"examples/changing_environment.html#Changing-environments","page":"Changing environments","title":"Changing environments","text":"","category":"section"},{"location":"examples/changing_environment.html","page":"Changing environments","title":"Changing environments","text":"In this tutorial, we define a birth function that is time dependent.  This can be related to changing environment, where the optimal adaptive trait changes because of underlying resource variability, e.g. related to climate.","category":"page"},{"location":"examples/changing_environment.html#Defining-the-variation","page":"Changing environments","title":"Defining the variation","text":"","category":"section"},{"location":"examples/changing_environment.html","page":"Changing environments","title":"Changing environments","text":"  ω = 2* π / 150 # angular frequency\n  optimal_trait(t) = sin(ω * t)\n  tend = 300\n  Plots.plot(1:tend,optimal_trait,label = \"Optimal trait\",xlabel = \"time\")","category":"page"},{"location":"examples/changing_environment.html","page":"Changing environments","title":"Changing environments","text":"(Image: )","category":"page"},{"location":"examples/changing_environment.html#Running","page":"Changing environments","title":"Running","text":"","category":"section"},{"location":"examples/changing_environment.html","page":"Changing environments","title":"Changing environments","text":"optimal_trait function is fed into the birth function, that we define as gaussian.","category":"page"},{"location":"examples/changing_environment.html","page":"Changing environments","title":"Changing environments","text":"  myspace = (RealSpace{1,Float64}(),)\n  K0 = 1000 # We will have in total 1000 individuals\n  b(X,t) = gaussian(X[1],optimal_trait(t),1)\n  d(X,Y,t) = 1/K0\n  D = (5e-2,)\n  mu = [1.]\n  NMax = 2000\n  p = Dict{String,Any}();@pack! p = D,mu,NMax\n  myagents = [Agent(myspace,(0,),ancestors=true,rates=true) for i in 1:K0]\n  w0 = World(myagents,myspace,p,0.)\n  @time sim = run!(w0, Gillepsie(), tend, b, d, dt_saving=3.)","category":"page"},{"location":"examples/changing_environment.html#Plotting","page":"Changing environments","title":"Plotting","text":"","category":"section"},{"location":"examples/changing_environment.html","page":"Changing environments","title":"Changing environments","text":"Plots.plot(sim)","category":"page"},{"location":"examples/changing_environment.html","page":"Changing environments","title":"Changing environments","text":"(Image: )","category":"page"},{"location":"manual/diversity.html#Metrics","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"manual/diversity.html","page":"Metrics","title":"Metrics","text":"Modules = [EvoId]\nPages   = [\"metrics.jl\"]","category":"page"},{"location":"manual/diversity.html#EvoId.H_discrete-Tuple{Any}","page":"Metrics","title":"EvoId.H_discrete","text":"H_discrete(s)\n\nInterconnectedness measure as in Nordbotten 2018 for discrete setup.\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#EvoId.covgeo","page":"Metrics","title":"EvoId.covgeo","text":"covgeo(world::Array{Agent,1},trait = 0)\n\nIf trait = 0, returns the variance of the geotrait, knowing that by default it is associated with position trait 1. If trait > 0, returns the covariance matrix, with first row geotrait and second row trait\n\nNotes\n\nThis might be deprecated in the future\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#EvoId.findclusters","page":"Metrics","title":"EvoId.findclusters","text":"findclusters(v::Vector,allextrema =true)\n\nReturns a tuple with the cluster mean and its associated weight.\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#EvoId.get_alpha_div","page":"Metrics","title":"EvoId.get_alpha_div","text":"get_alpha_div(world::Array{U,1},t::Number,trait=1) where U <: Union{Missing,Agent}\n\nMean of the local variance of trait per patch. If trait=0, we get the mean of the local variance of the geotrait If average = false, returns the alpha div for each patch, ordered by vertices\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#EvoId.get_beta_div","page":"Metrics","title":"EvoId.get_beta_div","text":"get_beta_div(world::Array{U,1},t::Number,trait=1) where U <: Union{Missing,Agent}\n\nVariance of the mean of trait per patch\n\nArguments\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#EvoId.get_dist_hist","page":"Metrics","title":"EvoId.get_dist_hist","text":"function get_dist_hist(a1,a2,dist,trait=1,time = 0)\n\nReturns the integral of the distance dist through time of trait between a1.x and a2.x.\n\nint d(x_1x_2t)dt\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#EvoId.get_local_abundance","page":"Metrics","title":"EvoId.get_local_abundance","text":"get_alpha_div(world::Array{U,1},t::Number,trait=1) where U <: Union{Missing,Agent}\n\nMean of the local variance of trait per patch. If trait=0, we get the mean of the local variance of the geotrait If average = false, returns the alpha div for each patch, ordered by vertices\n\n\n\n\n\n","category":"function"},{"location":"manual/diversity.html#EvoId.get_local_pairwise_average_isolation-Tuple{World}","page":"Metrics","title":"EvoId.get_local_pairwise_average_isolation","text":"function get_local_pairwise_average_isolation(world,dist,trait=1)\n\nSimilar to get_pairwise_average_isolation, but the pairwise distance is calculated within demes. An average of this metrics by deme is return.\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#EvoId.get_pairwise_average_isolation-Tuple{World}","page":"Metrics","title":"EvoId.get_pairwise_average_isolation","text":"function get_pairwise_average_isolation(world;trait=1,trunc=false)\n\nReturns the integrated pairwise squared distance between all agents of world wrt trait. If trunc=true then the distance is truncated to binary value 0 or 1.\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#EvoId.hamming-Union{Tuple{World}, Tuple{T}} where T<:Int64","page":"Metrics","title":"EvoId.hamming","text":"hamming(world::Array{Agent,1})\n\nReturns a matrix H where Hij = hamming(ai,a_j). The hamming distance is taken through the whole history and functional space of the agents.\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#Statistics.mean-Tuple{World}","page":"Metrics","title":"Statistics.mean","text":"mean(world::World;trait=1)\n\nReturns the mean of the world's trait distribution. If trait = 0, returns the variance of the geotrait,\n\n\n\n\n\n","category":"method"},{"location":"manual/diversity.html#Statistics.var-Tuple{World}","page":"Metrics","title":"Statistics.var","text":"var(world::World;trait=1)\n\nReturn the variance of the world's trait distribution. If trait = 0, returns the variance of the geotrait, knowing that by default it is associated with position trait 1.\n\nNotes\n\nFor now, the variance of a trait defined on a GraphSpace is calculated thanks to the Fiedler vector (cf https://mathworld.wolfram.com/FiedlerVector.html)\n\n\n\n\n\n","category":"method"},{"location":"examples/genetic_structure.html#genetic_structure","page":"Modelling agents with a genetic structure","title":"Modelling agents with a genetic structure","text":"","category":"section"},{"location":"examples/genetic_structure.html","page":"Modelling agents with a genetic structure","title":"Modelling agents with a genetic structure","text":"In this example, we show how to model a population evolving over a linear geographic space. The population is also defined by a genotype, which corresponds to the node of a genotype graph. The concept of genotype graph is better explained in The architecture of an empirical genotype-phenotype map. Any two connected nodes in the genotype graph should be thought of as two related genomes, i.e that are very similar in their alleles / nucleotide. As such, if the genotype of an offspring differs from its parent, it will be located in the neighbourhood of it parent's genotype node.","category":"page"},{"location":"examples/genetic_structure.html#Defining-the-space","page":"Modelling agents with a genetic structure","title":"Defining the space","text":"","category":"section"},{"location":"examples/genetic_structure.html","page":"Modelling agents with a genetic structure","title":"Modelling agents with a genetic structure","text":"    ##### Genotype space#####\n    dim_neutr = 1000\n    magicprop = 523728 / 32896\n    g = SimpleGraph{Int16}(dim_neutr,round(Int16,dim_neutr * magicprop))\n    initnode = argmax(eigenvector_centrality(g)) # This is the central node the we will use to instantiate the populations\n    myspace = (DiscreteSegment(Int8(1),Int8(nodes)),GraphSpace(g)) # union of vector spaces","category":"page"},{"location":"examples/genetic_structure.html#Defining-birth,-death-processes-and-mutation","page":"Modelling agents with a genetic structure","title":"Defining birth, death processes and mutation","text":"","category":"section"},{"location":"examples/genetic_structure.html","page":"Modelling agents with a genetic structure","title":"Modelling agents with a genetic structure","text":"    K0 = 1000\n    mu = [1.,1.]\n    b(X,t) = 1 / nodes\n    d(X,Y,t) = (X[1] ≈ Y[1]) / K0\n    D = (5e-1,1.4825)","category":"page"},{"location":"examples/genetic_structure.html#Final-set-up","page":"Modelling agents with a genetic structure","title":"Final set up","text":"","category":"section"},{"location":"examples/genetic_structure.html","page":"Modelling agents with a genetic structure","title":"Modelling agents with a genetic structure","text":"    NMax = 2000\n    # tend = 1.5\n    tend = 3000\n    p_default = Dict{String,Any}();@pack! p_default = NMax,mu\n    myagents = [Agent(myspace,(rand(Int8(1):Int8(nodes)),initnode),ancestors=true,rates=true) for i in 1:round(K0/nodes)]\n    w0 = World(myagents,myspace,p_default,0.)","category":"page"},{"location":"examples/genetic_structure.html#Plotting","page":"Modelling agents with a genetic structure","title":"Plotting","text":"","category":"section"},{"location":"examples/genetic_structure.html","page":"Modelling agents with a genetic structure","title":"Modelling agents with a genetic structure","text":"Plotting animations of graphs is a bit involved. If you want to learn about that, consult  src/examples/genetic_structure.jl.","category":"page"},{"location":"examples/genetic_structure.html#Geographical-space","page":"Modelling agents with a genetic structure","title":"Geographical space","text":"","category":"section"},{"location":"examples/genetic_structure.html","page":"Modelling agents with a genetic structure","title":"Modelling agents with a genetic structure","text":"(Image: )","category":"page"},{"location":"examples/genetic_structure.html#Genetic-space","page":"Modelling agents with a genetic structure","title":"Genetic space","text":"","category":"section"},{"location":"examples/genetic_structure.html","page":"Modelling agents with a genetic structure","title":"Modelling agents with a genetic structure","text":"(Image: )","category":"page"},{"location":"index.html#EvoId.jl","page":"Home","title":"EvoId.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"EvoId.jl (for Evolutionary Individual-based models) is a package aimed at simulating the eco-evolutionary dynamics of a population in a multidimensional space, at the individual level. The dynamics is specified under the framework of stochastic models for structured populations.","category":"page"},{"location":"notes/gillepsie.html#Gillepsie-simulation","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"","category":"section"},{"location":"notes/gillepsie.html#Diversification","page":"Gillepsie simulation","title":"Diversification","text":"","category":"section"},{"location":"notes/gillepsie.html#Gaussian-birth-coefficient,-Constant-carrying-capacity","page":"Gillepsie simulation","title":"Gaussian birth coefficient, Constant carrying capacity","text":"","category":"section"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"a = 0;\nsigma_K = .9;\nsigma_a = .7;\nK0 = 1000;\nK(X) = gaussian(X[1],0.,sigma_K)\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0\n# α(X,Y) = 0.\np_default = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 2000,\n        \"NMax\" => Int(2000),\n        \"dt_saving\" => 10.0)\nna_init = K0\nworld0 = new_world_G(na_init,p_default,spread = .01)","category":"page"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: EvoId_div_t4000)","category":"page"},{"location":"notes/gillepsie.html#Constant-birth-coefficient,-Gaussian-carrying-capacity","page":"Gillepsie simulation","title":"Constant birth coefficient, Gaussian carrying capacity","text":"","category":"section"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"a = 0;\nsigma_K = .9;\nsigma_a = .7;\nK0 = 1000;\nK(X) = 1\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0 / gaussian(X[1],0.,sigma_K)\n# α(X,Y) = 0.\np_default = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 4000,\n        \"NMax\" => Int(2000),\n        \"dt_saving\" => 20.0)\nna_init = K0","category":"page"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: EvoId_bis_div.ong)","category":"page"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"what you could do would be to plot the adaptive dynamics of the monomorphic populations","category":"page"},{"location":"notes/gillepsie.html#Quadratic-birth-rate","page":"Gillepsie simulation","title":"Quadratic birth rate","text":"","category":"section"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"a = 0.125;\nsigma_a = 1.251;\nK0 = 1000;\nK(X) =  1 - a * X[1]^2\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0\n# α(X,Y) = 0.\np_default = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 4000,\n        \"NMax\" => Int(2000),\n        \"dt_saving\" => 20.0)\nna_init = K0","category":"page"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: Unknown)","category":"page"},{"location":"notes/gillepsie.html#Equivalence","page":"Gillepsie simulation","title":"Equivalence","text":"","category":"section"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: PDE_quad_termsol) (Image: EvoId_quad_time_average_distrib_deep_time)","category":"page"},{"location":"notes/gillepsie.html#No-diversification","page":"Gillepsie simulation","title":"No diversification","text":"","category":"section"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"a = 0;\nsigma_K = .9;\nsigma_a = 1.0;\nK0 = 1000;\nK(X) = gaussian(X[1],0.,sigma_K)\nα(X,Y) = gaussian(X[1],Y[1],sigma_a)/K0\n# α(X,Y) = 0.\np_default = Dict(\n        \"alpha\" => α,\n        \"K\" => K,\n        \"D\" => [1e-2],\n        \"mu\" => [.1],\n        \"tend\" => 2000,\n        \"NMax\" => Int(2000),\n        \"dt_saving\" => 10.0)\nna_init = K0","category":"page"},{"location":"notes/gillepsie.html","page":"Gillepsie simulation","title":"Gillepsie simulation","text":"(Image: Gillepsie_results_nodiversification)","category":"page"},{"location":"manual/utils.html#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"manual/utils.html","page":"Utils","title":"Utils","text":"Modules = [EvoId]\nPages   = [\"utils.jl\"]","category":"page"},{"location":"manual/utils.html#DataFrames.groupby-Union{Tuple{T}, Tuple{Any,Array{T,N} where N}} where T","page":"Utils","title":"DataFrames.groupby","text":"groupby(f, list::Array)\n\nreturns a dictionary that group list elements by value of function f\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.arithsmooth-Tuple{Any,Any,Any}","page":"Utils","title":"EvoId.arithsmooth","text":"arithsmooth(x,y,smooth)\n\nReturning a tuple\n\nArguments\n\n-x is the shifted x-axis vector, due to smoothing -y is the smoothed value\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.arithsmooth-Tuple{Any,Any}","page":"Utils","title":"EvoId.arithsmooth","text":"arithsmooth(x,smooth)\n\narithmetic smoothing\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.arithsmooth2D-NTuple{4,Any}","page":"Utils","title":"EvoId.arithsmooth2D","text":"arithsmooth2D(xa,ya,itp,smooth)\n\nReturns xas, yas, A where A is an interpolated matrix with arithmetic smooth, whose axis are xas, yas\n\nArguments\n\nxa xaxis values, ya yaxis values,  itp interpolation function, smooth smoothing function\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.gaussian-Tuple{Number,Number,Number}","page":"Utils","title":"EvoId.gaussian","text":"gaussian(x::Number,mu::Number,sigma::Number) = generalised_gaussian(x,mu,sigma,2)\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.generalised_gaussian-NTuple{4,Number}","page":"Utils","title":"EvoId.generalised_gaussian","text":"    generalised_gaussian(x::Number,mu::Number,sigma::Number,epsilon::Number)\n\nReturns exp( -.5 * ((x-mu) / sigma)^epsilon)\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.geomsmooth-Tuple{Any,Any,Any}","page":"Utils","title":"EvoId.geomsmooth","text":"geomsmooth(x,y,smooth)\n\nReturning a tuple\n\nArguments\n\n-x is the shifted x-axis vector, due to smoothing -y is the smoothed value\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.geomsmooth-Tuple{Any,Any}","page":"Utils","title":"EvoId.geomsmooth","text":"geomsmooth(x,smooth)\n\nGeometric smoothing, cf https://en.wikipedia.org/wiki/Exponential_smoothing\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.geomsmooth2D-NTuple{4,Any}","page":"Utils","title":"EvoId.geomsmooth2D","text":"geomsmooth2D(xa,ya,itp,smooth)\n\nReturns xas, yas, A where A is an interpolated matrix with geometric smooth, whose axis are xas, yas.\n\nArguments\n\nxa xaxis values, ya yaxis values,  itp interpolation function, smooth smoothing function\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.interpolate_df-NTuple{4,Any}","page":"Utils","title":"EvoId.interpolate_df","text":"interpolate_df(df,xlab,ylab,zlab)\n\nreturns an interpolated function itp(x,y) -> z, as well as its axis xa and ya\n\n\n\n\n\n","category":"method"},{"location":"manual/utils.html#EvoId.ma-Union{Tuple{T}, Tuple{Array{T,N} where N,Any}} where T<:Number","page":"Utils","title":"EvoId.ma","text":"ma(x::Array{T},f) where T <: Number\n\nMoving average over array x, using f as the filter, i.e. the number of points to average on. Better choosing an odd number\n\n\n\n\n\n","category":"method"}]
}
